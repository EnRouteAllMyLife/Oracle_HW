---
title: "Report"
date: "2024-03-16"
output: 
    html_document:
    toc: true
    toc_float: true
    code_folding: "hide"
---


```{r setup}
library(tidyverse)
library(readr)
library(plotme)
library(glmnet)
knitr::opts_chunk$set(
  warning = FALSE, 
  message = FALSE,
  fig.dim = c(12, 7))

theme_set(theme_minimal() + theme(legend.position = "bottom"))
```


# EDA


```{r load data}
df_raw = read.delim("./Data/nhwsdata.txt") 
```



```{r}
df = df_raw |>
  # deal with nominal data
  mutate(DBTYPE = if_else(is.na(DBTYPE), 0, DBTYPE),
         DBRX = if_else(DBRX == 1, 1, 0, missing = 0),
         DBIN = if_else(DBIN == 1, 1, 0, missing = 0)) |>
  mutate(across(c(DESEX, DBDX,DBTYPE,DBRX,DBIN), ~factor(.))) |>
 # mutate(across(c(BP, GH, MH, PF, RE, RP,VT, SF,MMAS), ~factor(., ordered = TRUE))) |>
  mutate(across(c(BP, GH, MH, PF, RE, RP,VT, SF,MMAS), ~factor(.))) 
df_encode = df |>
  mutate(DESEX = factor(DESEX, levels = c(1, 2), labels = c("Male", "Female")),
         DBDX = factor(DBDX, levels = c(0, 1), labels = c("Not Diagnosed", "Diagnosed")),
         DBTYPE = factor(DBTYPE, levels = c(0, 1, 2), labels = c("Not Diagnosed", "Type 1", "Type 2")),
         DBRX = factor(DBRX, levels = c(0, 1), labels = c("Not Using Oral", "Using Oral")),
         DBIN = factor(DBIN, levels = c(0, 1), labels = c("Not Using Insulin", "Using Insulin"))) 
  
  
df |> skimr:: skim()
```

```{r con cat lists}
# Detecting continuous and categorical variables
continuous_vars <- c()
categorical_vars <- c()

for(col_name in names(df)) {
  # Assuming continuous variables are of type numeric and have more unique values
  if(is.numeric(df[[col_name]]) && length(unique(df[[col_name]])) > 10) { 
    continuous_vars <- c(continuous_vars, col_name)
  } else { 
    categorical_vars <- c(categorical_vars, col_name)
  }
}
continuous_vars = continuous_vars[-1]
```


```{r, relationship of disease, type, oral and insulin use}
df_encode |>
  count(DBDX, DBTYPE, DBIN, DBRX#,wt = RUHP6Q
        ) |>
  count_to_sunburst(fill_by_n = TRUE)
```
## Implement

```{r implement}
df |> filter(!is.na(BMI)) |> group_by(DBDX) |> summarise(mean(BMI))

df = df |>
  mutate(BMI = if_else(is.na(BMI) & DBDX == 0,27.95397,
                       if_else(is.na(BMI) & DBDX == 1, 33.21504,BMI)),
         MMAS = as.numeric(as.character(MMAS)),
         MMAS = if_else(is.na(MMAS),-1,MMAS))
df_encode = df_encode |>
  
  mutate(BMI = if_else(is.na(BMI) & DBDX == 0,27.95397,
                       if_else(is.na(BMI) & DBDX == 1, 33.21504,BMI)),
         MMAS = as.numeric(as.character(MMAS)),
         MMAS = if_else(is.na(MMAS),-1,MMAS))
ggplot(df_encode, aes(x = BMI,col = DBDX)) +geom_density()
```

```{r categorical univarite}
cat_result = tibble(
  vars = categorical_vars) |>
  filter(!(vars %in% c("DBRX","DBIN","DBDX","DBTYPE"))) |> # filter these out for 0 values
  mutate(summary = map(vars, \(x) chisq.test(df[[x]], df[['DBDX']])),
         summary = map(summary, broom::tidy ))|>
  unnest(summary) |>
  select(vars,statistic,p.value) |>
  mutate(if_sig = if_else(p.value < 0.05,1,0))
cat_result
```



```{r continuous univarite}
con_result = tibble(
  vars = continuous_vars) |>
  #filter(!(vars %in% c("zKey"))) |> # filter these out for 0 values
  mutate(#x = df|>filter(DBDX == 0) |> select(vars))
         summary = map(vars, \(x) wilcox.test(df|>filter(DBDX == 0) |> select(x) |> pull(),
                                              df|>filter(DBDX == 1) |> select(x) |> pull())),
         summary = map(summary, broom::tidy ))|>
  unnest(summary) |>
  select(vars,statistic,p.value) |>
  mutate(if_sig = if_else(p.value < 0.05,1,0))
con_result
```

```{r}
corrplot::corrplot(cor(df |> select(any_of(continuous_vars))), "number")
```

# Possion Regression


```{r, eval = FALSE}

df_type2 = df |> filter(DBTYPE == 2)



x_matrix <- model.matrix(~ DEAGE+DESEX+BMI+DBRX+DBIN+
                           CCI+MMAS+PCS+MCS+BP+GH+VT+SF+MH+RE+RP+PF+WPACTIMP, data = df_type2 )[, -1] # Creating a model matrix, excluding the intercept
y_vector <- df_type2$RUHP6Q

lambda_values <- 10^seq(-10, 0, length.out=100)
# Fit a Poisson regression model using glmnet (for demonstration, using LASSO)
cv_fit <- cv.glmnet(x_matrix, y_vector,
                     family = "poisson", 
                    alpha = 1,standardize=TRUE, lambda = lambda_values)

# Plot the cross-validation curve
plot(cv_fit)

# Extract the best model (lambda value that gives minimum mean cross-validated error)
best_lambda <- cv_fit$lambda.min

# Fit the model with the selected lambda
best_model <- glmnet(x_matrix, y_vector, standardize=TRUE,
                     family = "poisson",maxit=1000000, alpha = 1, lambda = best_lambda)

```

```{r, eval = FALSE}
for (i in continuous_vars){
  p = ggplot(df_type2,aes_string(x = 'RUHP6Q',y = i))+geom_point() +geom_smooth()
  print(p)
}

```


